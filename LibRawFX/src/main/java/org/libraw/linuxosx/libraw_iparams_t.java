// Generated by jextract

package org.libraw.linuxosx;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct {
 *     char guard[4];
 *     char make[64];
 *     char model[64];
 *     char software[64];
 *     char normalized_make[64];
 *     char normalized_model[64];
 *     unsigned int maker_index;
 *     unsigned int raw_count;
 *     unsigned int dng_version;
 *     unsigned int is_foveon;
 *     int colors;
 *     unsigned int filters;
 *     char xtrans[6][6];
 *     char xtrans_abs[6][6];
 *     char cdesc[5];
 *     unsigned int xmplen;
 *     char *xmpdata;
 * }
 * }
 */
public class libraw_iparams_t {

    libraw_iparams_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.sequenceLayout(4, libraw_h.C_CHAR).withName("guard"),
        MemoryLayout.sequenceLayout(64, libraw_h.C_CHAR).withName("make"),
        MemoryLayout.sequenceLayout(64, libraw_h.C_CHAR).withName("model"),
        MemoryLayout.sequenceLayout(64, libraw_h.C_CHAR).withName("software"),
        MemoryLayout.sequenceLayout(64, libraw_h.C_CHAR).withName("normalized_make"),
        MemoryLayout.sequenceLayout(64, libraw_h.C_CHAR).withName("normalized_model"),
        libraw_h.C_INT.withName("maker_index"),
        libraw_h.C_INT.withName("raw_count"),
        libraw_h.C_INT.withName("dng_version"),
        libraw_h.C_INT.withName("is_foveon"),
        libraw_h.C_INT.withName("colors"),
        libraw_h.C_INT.withName("filters"),
        MemoryLayout.sequenceLayout(6, MemoryLayout.sequenceLayout(6, libraw_h.C_CHAR)).withName("xtrans"),
        MemoryLayout.sequenceLayout(6, MemoryLayout.sequenceLayout(6, libraw_h.C_CHAR)).withName("xtrans_abs"),
        MemoryLayout.sequenceLayout(5, libraw_h.C_CHAR).withName("cdesc"),
        MemoryLayout.paddingLayout(3),
        libraw_h.C_INT.withName("xmplen"),
        libraw_h.C_POINTER.withName("xmpdata")
    ).withName("$anon$178:11");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final SequenceLayout guard$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("guard"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char guard[4]
     * }
     */
    public static final SequenceLayout guard$layout() {
        return guard$LAYOUT;
    }

    private static final long guard$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char guard[4]
     * }
     */
    public static final long guard$offset() {
        return guard$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char guard[4]
     * }
     */
    public static MemorySegment guard(MemorySegment struct) {
        return struct.asSlice(guard$OFFSET, guard$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char guard[4]
     * }
     */
    public static void guard(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, guard$OFFSET, guard$LAYOUT.byteSize());
    }

    private static long[] guard$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char guard[4]
     * }
     */
    public static long[] guard$dimensions() {
        return guard$DIMS;
    }
    private static final VarHandle guard$ELEM_HANDLE = guard$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char guard[4]
     * }
     */
    public static byte guard(MemorySegment struct, long index0) {
        return (byte)guard$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char guard[4]
     * }
     */
    public static void guard(MemorySegment struct, long index0, byte fieldValue) {
        guard$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout make$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("make"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char make[64]
     * }
     */
    public static final SequenceLayout make$layout() {
        return make$LAYOUT;
    }

    private static final long make$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char make[64]
     * }
     */
    public static final long make$offset() {
        return make$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char make[64]
     * }
     */
    public static MemorySegment make(MemorySegment struct) {
        return struct.asSlice(make$OFFSET, make$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char make[64]
     * }
     */
    public static void make(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, make$OFFSET, make$LAYOUT.byteSize());
    }

    private static long[] make$DIMS = { 64 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char make[64]
     * }
     */
    public static long[] make$dimensions() {
        return make$DIMS;
    }
    private static final VarHandle make$ELEM_HANDLE = make$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char make[64]
     * }
     */
    public static byte make(MemorySegment struct, long index0) {
        return (byte)make$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char make[64]
     * }
     */
    public static void make(MemorySegment struct, long index0, byte fieldValue) {
        make$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout model$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("model"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char model[64]
     * }
     */
    public static final SequenceLayout model$layout() {
        return model$LAYOUT;
    }

    private static final long model$OFFSET = 68;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char model[64]
     * }
     */
    public static final long model$offset() {
        return model$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char model[64]
     * }
     */
    public static MemorySegment model(MemorySegment struct) {
        return struct.asSlice(model$OFFSET, model$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char model[64]
     * }
     */
    public static void model(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, model$OFFSET, model$LAYOUT.byteSize());
    }

    private static long[] model$DIMS = { 64 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char model[64]
     * }
     */
    public static long[] model$dimensions() {
        return model$DIMS;
    }
    private static final VarHandle model$ELEM_HANDLE = model$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char model[64]
     * }
     */
    public static byte model(MemorySegment struct, long index0) {
        return (byte)model$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char model[64]
     * }
     */
    public static void model(MemorySegment struct, long index0, byte fieldValue) {
        model$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout software$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("software"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char software[64]
     * }
     */
    public static final SequenceLayout software$layout() {
        return software$LAYOUT;
    }

    private static final long software$OFFSET = 132;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char software[64]
     * }
     */
    public static final long software$offset() {
        return software$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char software[64]
     * }
     */
    public static MemorySegment software(MemorySegment struct) {
        return struct.asSlice(software$OFFSET, software$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char software[64]
     * }
     */
    public static void software(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, software$OFFSET, software$LAYOUT.byteSize());
    }

    private static long[] software$DIMS = { 64 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char software[64]
     * }
     */
    public static long[] software$dimensions() {
        return software$DIMS;
    }
    private static final VarHandle software$ELEM_HANDLE = software$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char software[64]
     * }
     */
    public static byte software(MemorySegment struct, long index0) {
        return (byte)software$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char software[64]
     * }
     */
    public static void software(MemorySegment struct, long index0, byte fieldValue) {
        software$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout normalized_make$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("normalized_make"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char normalized_make[64]
     * }
     */
    public static final SequenceLayout normalized_make$layout() {
        return normalized_make$LAYOUT;
    }

    private static final long normalized_make$OFFSET = 196;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char normalized_make[64]
     * }
     */
    public static final long normalized_make$offset() {
        return normalized_make$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char normalized_make[64]
     * }
     */
    public static MemorySegment normalized_make(MemorySegment struct) {
        return struct.asSlice(normalized_make$OFFSET, normalized_make$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char normalized_make[64]
     * }
     */
    public static void normalized_make(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, normalized_make$OFFSET, normalized_make$LAYOUT.byteSize());
    }

    private static long[] normalized_make$DIMS = { 64 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char normalized_make[64]
     * }
     */
    public static long[] normalized_make$dimensions() {
        return normalized_make$DIMS;
    }
    private static final VarHandle normalized_make$ELEM_HANDLE = normalized_make$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char normalized_make[64]
     * }
     */
    public static byte normalized_make(MemorySegment struct, long index0) {
        return (byte)normalized_make$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char normalized_make[64]
     * }
     */
    public static void normalized_make(MemorySegment struct, long index0, byte fieldValue) {
        normalized_make$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout normalized_model$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("normalized_model"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char normalized_model[64]
     * }
     */
    public static final SequenceLayout normalized_model$layout() {
        return normalized_model$LAYOUT;
    }

    private static final long normalized_model$OFFSET = 260;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char normalized_model[64]
     * }
     */
    public static final long normalized_model$offset() {
        return normalized_model$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char normalized_model[64]
     * }
     */
    public static MemorySegment normalized_model(MemorySegment struct) {
        return struct.asSlice(normalized_model$OFFSET, normalized_model$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char normalized_model[64]
     * }
     */
    public static void normalized_model(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, normalized_model$OFFSET, normalized_model$LAYOUT.byteSize());
    }

    private static long[] normalized_model$DIMS = { 64 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char normalized_model[64]
     * }
     */
    public static long[] normalized_model$dimensions() {
        return normalized_model$DIMS;
    }
    private static final VarHandle normalized_model$ELEM_HANDLE = normalized_model$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char normalized_model[64]
     * }
     */
    public static byte normalized_model(MemorySegment struct, long index0) {
        return (byte)normalized_model$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char normalized_model[64]
     * }
     */
    public static void normalized_model(MemorySegment struct, long index0, byte fieldValue) {
        normalized_model$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfInt maker_index$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maker_index"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int maker_index
     * }
     */
    public static final OfInt maker_index$layout() {
        return maker_index$LAYOUT;
    }

    private static final long maker_index$OFFSET = 324;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int maker_index
     * }
     */
    public static final long maker_index$offset() {
        return maker_index$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int maker_index
     * }
     */
    public static int maker_index(MemorySegment struct) {
        return struct.get(maker_index$LAYOUT, maker_index$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int maker_index
     * }
     */
    public static void maker_index(MemorySegment struct, int fieldValue) {
        struct.set(maker_index$LAYOUT, maker_index$OFFSET, fieldValue);
    }

    private static final OfInt raw_count$LAYOUT = (OfInt)$LAYOUT.select(groupElement("raw_count"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int raw_count
     * }
     */
    public static final OfInt raw_count$layout() {
        return raw_count$LAYOUT;
    }

    private static final long raw_count$OFFSET = 328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int raw_count
     * }
     */
    public static final long raw_count$offset() {
        return raw_count$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int raw_count
     * }
     */
    public static int raw_count(MemorySegment struct) {
        return struct.get(raw_count$LAYOUT, raw_count$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int raw_count
     * }
     */
    public static void raw_count(MemorySegment struct, int fieldValue) {
        struct.set(raw_count$LAYOUT, raw_count$OFFSET, fieldValue);
    }

    private static final OfInt dng_version$LAYOUT = (OfInt)$LAYOUT.select(groupElement("dng_version"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int dng_version
     * }
     */
    public static final OfInt dng_version$layout() {
        return dng_version$LAYOUT;
    }

    private static final long dng_version$OFFSET = 332;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int dng_version
     * }
     */
    public static final long dng_version$offset() {
        return dng_version$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int dng_version
     * }
     */
    public static int dng_version(MemorySegment struct) {
        return struct.get(dng_version$LAYOUT, dng_version$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int dng_version
     * }
     */
    public static void dng_version(MemorySegment struct, int fieldValue) {
        struct.set(dng_version$LAYOUT, dng_version$OFFSET, fieldValue);
    }

    private static final OfInt is_foveon$LAYOUT = (OfInt)$LAYOUT.select(groupElement("is_foveon"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int is_foveon
     * }
     */
    public static final OfInt is_foveon$layout() {
        return is_foveon$LAYOUT;
    }

    private static final long is_foveon$OFFSET = 336;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int is_foveon
     * }
     */
    public static final long is_foveon$offset() {
        return is_foveon$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int is_foveon
     * }
     */
    public static int is_foveon(MemorySegment struct) {
        return struct.get(is_foveon$LAYOUT, is_foveon$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int is_foveon
     * }
     */
    public static void is_foveon(MemorySegment struct, int fieldValue) {
        struct.set(is_foveon$LAYOUT, is_foveon$OFFSET, fieldValue);
    }

    private static final OfInt colors$LAYOUT = (OfInt)$LAYOUT.select(groupElement("colors"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int colors
     * }
     */
    public static final OfInt colors$layout() {
        return colors$LAYOUT;
    }

    private static final long colors$OFFSET = 340;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int colors
     * }
     */
    public static final long colors$offset() {
        return colors$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int colors
     * }
     */
    public static int colors(MemorySegment struct) {
        return struct.get(colors$LAYOUT, colors$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int colors
     * }
     */
    public static void colors(MemorySegment struct, int fieldValue) {
        struct.set(colors$LAYOUT, colors$OFFSET, fieldValue);
    }

    private static final OfInt filters$LAYOUT = (OfInt)$LAYOUT.select(groupElement("filters"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int filters
     * }
     */
    public static final OfInt filters$layout() {
        return filters$LAYOUT;
    }

    private static final long filters$OFFSET = 344;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int filters
     * }
     */
    public static final long filters$offset() {
        return filters$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int filters
     * }
     */
    public static int filters(MemorySegment struct) {
        return struct.get(filters$LAYOUT, filters$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int filters
     * }
     */
    public static void filters(MemorySegment struct, int fieldValue) {
        struct.set(filters$LAYOUT, filters$OFFSET, fieldValue);
    }

    private static final SequenceLayout xtrans$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("xtrans"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char xtrans[6][6]
     * }
     */
    public static final SequenceLayout xtrans$layout() {
        return xtrans$LAYOUT;
    }

    private static final long xtrans$OFFSET = 348;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char xtrans[6][6]
     * }
     */
    public static final long xtrans$offset() {
        return xtrans$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char xtrans[6][6]
     * }
     */
    public static MemorySegment xtrans(MemorySegment struct) {
        return struct.asSlice(xtrans$OFFSET, xtrans$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char xtrans[6][6]
     * }
     */
    public static void xtrans(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, xtrans$OFFSET, xtrans$LAYOUT.byteSize());
    }

    private static long[] xtrans$DIMS = { 6, 6 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char xtrans[6][6]
     * }
     */
    public static long[] xtrans$dimensions() {
        return xtrans$DIMS;
    }
    private static final VarHandle xtrans$ELEM_HANDLE = xtrans$LAYOUT.varHandle(sequenceElement(), sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char xtrans[6][6]
     * }
     */
    public static byte xtrans(MemorySegment struct, long index0, long index1) {
        return (byte)xtrans$ELEM_HANDLE.get(struct, 0L, index0, index1);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char xtrans[6][6]
     * }
     */
    public static void xtrans(MemorySegment struct, long index0, long index1, byte fieldValue) {
        xtrans$ELEM_HANDLE.set(struct, 0L, index0, index1, fieldValue);
    }

    private static final SequenceLayout xtrans_abs$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("xtrans_abs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char xtrans_abs[6][6]
     * }
     */
    public static final SequenceLayout xtrans_abs$layout() {
        return xtrans_abs$LAYOUT;
    }

    private static final long xtrans_abs$OFFSET = 384;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char xtrans_abs[6][6]
     * }
     */
    public static final long xtrans_abs$offset() {
        return xtrans_abs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char xtrans_abs[6][6]
     * }
     */
    public static MemorySegment xtrans_abs(MemorySegment struct) {
        return struct.asSlice(xtrans_abs$OFFSET, xtrans_abs$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char xtrans_abs[6][6]
     * }
     */
    public static void xtrans_abs(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, xtrans_abs$OFFSET, xtrans_abs$LAYOUT.byteSize());
    }

    private static long[] xtrans_abs$DIMS = { 6, 6 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char xtrans_abs[6][6]
     * }
     */
    public static long[] xtrans_abs$dimensions() {
        return xtrans_abs$DIMS;
    }
    private static final VarHandle xtrans_abs$ELEM_HANDLE = xtrans_abs$LAYOUT.varHandle(sequenceElement(), sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char xtrans_abs[6][6]
     * }
     */
    public static byte xtrans_abs(MemorySegment struct, long index0, long index1) {
        return (byte)xtrans_abs$ELEM_HANDLE.get(struct, 0L, index0, index1);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char xtrans_abs[6][6]
     * }
     */
    public static void xtrans_abs(MemorySegment struct, long index0, long index1, byte fieldValue) {
        xtrans_abs$ELEM_HANDLE.set(struct, 0L, index0, index1, fieldValue);
    }

    private static final SequenceLayout cdesc$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("cdesc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char cdesc[5]
     * }
     */
    public static final SequenceLayout cdesc$layout() {
        return cdesc$LAYOUT;
    }

    private static final long cdesc$OFFSET = 420;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char cdesc[5]
     * }
     */
    public static final long cdesc$offset() {
        return cdesc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char cdesc[5]
     * }
     */
    public static MemorySegment cdesc(MemorySegment struct) {
        return struct.asSlice(cdesc$OFFSET, cdesc$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char cdesc[5]
     * }
     */
    public static void cdesc(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, cdesc$OFFSET, cdesc$LAYOUT.byteSize());
    }

    private static long[] cdesc$DIMS = { 5 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char cdesc[5]
     * }
     */
    public static long[] cdesc$dimensions() {
        return cdesc$DIMS;
    }
    private static final VarHandle cdesc$ELEM_HANDLE = cdesc$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char cdesc[5]
     * }
     */
    public static byte cdesc(MemorySegment struct, long index0) {
        return (byte)cdesc$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char cdesc[5]
     * }
     */
    public static void cdesc(MemorySegment struct, long index0, byte fieldValue) {
        cdesc$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfInt xmplen$LAYOUT = (OfInt)$LAYOUT.select(groupElement("xmplen"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int xmplen
     * }
     */
    public static final OfInt xmplen$layout() {
        return xmplen$LAYOUT;
    }

    private static final long xmplen$OFFSET = 428;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int xmplen
     * }
     */
    public static final long xmplen$offset() {
        return xmplen$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int xmplen
     * }
     */
    public static int xmplen(MemorySegment struct) {
        return struct.get(xmplen$LAYOUT, xmplen$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int xmplen
     * }
     */
    public static void xmplen(MemorySegment struct, int fieldValue) {
        struct.set(xmplen$LAYOUT, xmplen$OFFSET, fieldValue);
    }

    private static final AddressLayout xmpdata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xmpdata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *xmpdata
     * }
     */
    public static final AddressLayout xmpdata$layout() {
        return xmpdata$LAYOUT;
    }

    private static final long xmpdata$OFFSET = 432;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *xmpdata
     * }
     */
    public static final long xmpdata$offset() {
        return xmpdata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *xmpdata
     * }
     */
    public static MemorySegment xmpdata(MemorySegment struct) {
        return struct.get(xmpdata$LAYOUT, xmpdata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *xmpdata
     * }
     */
    public static void xmpdata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xmpdata$LAYOUT, xmpdata$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

