// Generated by jextract

package org.libraw.nativ;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct {
 *     float iso_speed;
 *     float shutter;
 *     float aperture;
 *     float focal_len;
 *     time_t timestamp;
 *     unsigned int shot_order;
 *     unsigned int gpsdata[32];
 *     libraw_gps_info_t parsed_gps;
 *     char desc[512];
 *     char artist[64];
 *     float analogbalance[4];
 * }
 * }
 */
public class libraw_imgother_t {

    libraw_imgother_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        libraw_h.C_FLOAT.withName("iso_speed"),
        libraw_h.C_FLOAT.withName("shutter"),
        libraw_h.C_FLOAT.withName("aperture"),
        libraw_h.C_FLOAT.withName("focal_len"),
        libraw_h.C_LONG_LONG.withName("timestamp"),
        libraw_h.C_INT.withName("shot_order"),
        MemoryLayout.sequenceLayout(32, libraw_h.C_INT).withName("gpsdata"),
        libraw_gps_info_t.layout().withName("parsed_gps"),
        MemoryLayout.sequenceLayout(512, libraw_h.C_CHAR).withName("desc"),
        MemoryLayout.sequenceLayout(64, libraw_h.C_CHAR).withName("artist"),
        MemoryLayout.sequenceLayout(4, libraw_h.C_FLOAT).withName("analogbalance"),
        MemoryLayout.paddingLayout(4)
    ).withName("$anon$838:11");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfFloat iso_speed$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("iso_speed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float iso_speed
     * }
     */
    public static final OfFloat iso_speed$layout() {
        return iso_speed$LAYOUT;
    }

    private static final long iso_speed$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float iso_speed
     * }
     */
    public static final long iso_speed$offset() {
        return iso_speed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float iso_speed
     * }
     */
    public static float iso_speed(MemorySegment struct) {
        return struct.get(iso_speed$LAYOUT, iso_speed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float iso_speed
     * }
     */
    public static void iso_speed(MemorySegment struct, float fieldValue) {
        struct.set(iso_speed$LAYOUT, iso_speed$OFFSET, fieldValue);
    }

    private static final OfFloat shutter$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("shutter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float shutter
     * }
     */
    public static final OfFloat shutter$layout() {
        return shutter$LAYOUT;
    }

    private static final long shutter$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float shutter
     * }
     */
    public static final long shutter$offset() {
        return shutter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float shutter
     * }
     */
    public static float shutter(MemorySegment struct) {
        return struct.get(shutter$LAYOUT, shutter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float shutter
     * }
     */
    public static void shutter(MemorySegment struct, float fieldValue) {
        struct.set(shutter$LAYOUT, shutter$OFFSET, fieldValue);
    }

    private static final OfFloat aperture$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("aperture"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float aperture
     * }
     */
    public static final OfFloat aperture$layout() {
        return aperture$LAYOUT;
    }

    private static final long aperture$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float aperture
     * }
     */
    public static final long aperture$offset() {
        return aperture$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float aperture
     * }
     */
    public static float aperture(MemorySegment struct) {
        return struct.get(aperture$LAYOUT, aperture$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float aperture
     * }
     */
    public static void aperture(MemorySegment struct, float fieldValue) {
        struct.set(aperture$LAYOUT, aperture$OFFSET, fieldValue);
    }

    private static final OfFloat focal_len$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("focal_len"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float focal_len
     * }
     */
    public static final OfFloat focal_len$layout() {
        return focal_len$LAYOUT;
    }

    private static final long focal_len$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float focal_len
     * }
     */
    public static final long focal_len$offset() {
        return focal_len$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float focal_len
     * }
     */
    public static float focal_len(MemorySegment struct) {
        return struct.get(focal_len$LAYOUT, focal_len$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float focal_len
     * }
     */
    public static void focal_len(MemorySegment struct, float fieldValue) {
        struct.set(focal_len$LAYOUT, focal_len$OFFSET, fieldValue);
    }

    private static final OfLong timestamp$LAYOUT = (OfLong)$LAYOUT.select(groupElement("timestamp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * time_t timestamp
     * }
     */
    public static final OfLong timestamp$layout() {
        return timestamp$LAYOUT;
    }

    private static final long timestamp$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * time_t timestamp
     * }
     */
    public static final long timestamp$offset() {
        return timestamp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * time_t timestamp
     * }
     */
    public static long timestamp(MemorySegment struct) {
        return struct.get(timestamp$LAYOUT, timestamp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * time_t timestamp
     * }
     */
    public static void timestamp(MemorySegment struct, long fieldValue) {
        struct.set(timestamp$LAYOUT, timestamp$OFFSET, fieldValue);
    }

    private static final OfInt shot_order$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shot_order"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int shot_order
     * }
     */
    public static final OfInt shot_order$layout() {
        return shot_order$LAYOUT;
    }

    private static final long shot_order$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int shot_order
     * }
     */
    public static final long shot_order$offset() {
        return shot_order$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int shot_order
     * }
     */
    public static int shot_order(MemorySegment struct) {
        return struct.get(shot_order$LAYOUT, shot_order$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int shot_order
     * }
     */
    public static void shot_order(MemorySegment struct, int fieldValue) {
        struct.set(shot_order$LAYOUT, shot_order$OFFSET, fieldValue);
    }

    private static final SequenceLayout gpsdata$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("gpsdata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int gpsdata[32]
     * }
     */
    public static final SequenceLayout gpsdata$layout() {
        return gpsdata$LAYOUT;
    }

    private static final long gpsdata$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int gpsdata[32]
     * }
     */
    public static final long gpsdata$offset() {
        return gpsdata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int gpsdata[32]
     * }
     */
    public static MemorySegment gpsdata(MemorySegment struct) {
        return struct.asSlice(gpsdata$OFFSET, gpsdata$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int gpsdata[32]
     * }
     */
    public static void gpsdata(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, gpsdata$OFFSET, gpsdata$LAYOUT.byteSize());
    }

    private static long[] gpsdata$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * unsigned int gpsdata[32]
     * }
     */
    public static long[] gpsdata$dimensions() {
        return gpsdata$DIMS;
    }
    private static final VarHandle gpsdata$ELEM_HANDLE = gpsdata$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * unsigned int gpsdata[32]
     * }
     */
    public static int gpsdata(MemorySegment struct, long index0) {
        return (int)gpsdata$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * unsigned int gpsdata[32]
     * }
     */
    public static void gpsdata(MemorySegment struct, long index0, int fieldValue) {
        gpsdata$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final GroupLayout parsed_gps$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("parsed_gps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * libraw_gps_info_t parsed_gps
     * }
     */
    public static final GroupLayout parsed_gps$layout() {
        return parsed_gps$LAYOUT;
    }

    private static final long parsed_gps$OFFSET = 156;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * libraw_gps_info_t parsed_gps
     * }
     */
    public static final long parsed_gps$offset() {
        return parsed_gps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * libraw_gps_info_t parsed_gps
     * }
     */
    public static MemorySegment parsed_gps(MemorySegment struct) {
        return struct.asSlice(parsed_gps$OFFSET, parsed_gps$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * libraw_gps_info_t parsed_gps
     * }
     */
    public static void parsed_gps(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, parsed_gps$OFFSET, parsed_gps$LAYOUT.byteSize());
    }

    private static final SequenceLayout desc$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("desc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char desc[512]
     * }
     */
    public static final SequenceLayout desc$layout() {
        return desc$LAYOUT;
    }

    private static final long desc$OFFSET = 204;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char desc[512]
     * }
     */
    public static final long desc$offset() {
        return desc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char desc[512]
     * }
     */
    public static MemorySegment desc(MemorySegment struct) {
        return struct.asSlice(desc$OFFSET, desc$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char desc[512]
     * }
     */
    public static void desc(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, desc$OFFSET, desc$LAYOUT.byteSize());
    }

    private static long[] desc$DIMS = { 512 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char desc[512]
     * }
     */
    public static long[] desc$dimensions() {
        return desc$DIMS;
    }
    private static final VarHandle desc$ELEM_HANDLE = desc$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char desc[512]
     * }
     */
    public static byte desc(MemorySegment struct, long index0) {
        return (byte)desc$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char desc[512]
     * }
     */
    public static void desc(MemorySegment struct, long index0, byte fieldValue) {
        desc$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout artist$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("artist"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char artist[64]
     * }
     */
    public static final SequenceLayout artist$layout() {
        return artist$LAYOUT;
    }

    private static final long artist$OFFSET = 716;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char artist[64]
     * }
     */
    public static final long artist$offset() {
        return artist$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char artist[64]
     * }
     */
    public static MemorySegment artist(MemorySegment struct) {
        return struct.asSlice(artist$OFFSET, artist$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char artist[64]
     * }
     */
    public static void artist(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, artist$OFFSET, artist$LAYOUT.byteSize());
    }

    private static long[] artist$DIMS = { 64 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char artist[64]
     * }
     */
    public static long[] artist$dimensions() {
        return artist$DIMS;
    }
    private static final VarHandle artist$ELEM_HANDLE = artist$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char artist[64]
     * }
     */
    public static byte artist(MemorySegment struct, long index0) {
        return (byte)artist$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char artist[64]
     * }
     */
    public static void artist(MemorySegment struct, long index0, byte fieldValue) {
        artist$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout analogbalance$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("analogbalance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static final SequenceLayout analogbalance$layout() {
        return analogbalance$LAYOUT;
    }

    private static final long analogbalance$OFFSET = 780;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static final long analogbalance$offset() {
        return analogbalance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static MemorySegment analogbalance(MemorySegment struct) {
        return struct.asSlice(analogbalance$OFFSET, analogbalance$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static void analogbalance(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, analogbalance$OFFSET, analogbalance$LAYOUT.byteSize());
    }

    private static long[] analogbalance$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static long[] analogbalance$dimensions() {
        return analogbalance$DIMS;
    }
    private static final VarHandle analogbalance$ELEM_HANDLE = analogbalance$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static float analogbalance(MemorySegment struct, long index0) {
        return (float)analogbalance$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static void analogbalance(MemorySegment struct, long index0, float fieldValue) {
        analogbalance$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size @code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size @code elementCount} using {@code allocator}.
     * The returned segment has size @code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size @code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size @code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

