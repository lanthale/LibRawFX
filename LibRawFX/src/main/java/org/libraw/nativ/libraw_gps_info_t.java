// Generated by jextract

package org.libraw.nativ;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct {
 *     float latitude[3];
 *     float longitude[3];
 *     float gpstimestamp[3];
 *     float altitude;
 *     char altref;
 *     char latref;
 *     char longref;
 *     char gpsstatus;
 *     char gpsparsed;
 * }
 * }
 */
public class libraw_gps_info_t {

    libraw_gps_info_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.sequenceLayout(3, libraw_h.C_FLOAT).withName("latitude"),
        MemoryLayout.sequenceLayout(3, libraw_h.C_FLOAT).withName("longitude"),
        MemoryLayout.sequenceLayout(3, libraw_h.C_FLOAT).withName("gpstimestamp"),
        libraw_h.C_FLOAT.withName("altitude"),
        libraw_h.C_CHAR.withName("altref"),
        libraw_h.C_CHAR.withName("latref"),
        libraw_h.C_CHAR.withName("longref"),
        libraw_h.C_CHAR.withName("gpsstatus"),
        libraw_h.C_CHAR.withName("gpsparsed"),
        MemoryLayout.paddingLayout(3)
    ).withName("$anon$828:11");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final SequenceLayout latitude$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("latitude"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float latitude[3]
     * }
     */
    public static final SequenceLayout latitude$layout() {
        return latitude$LAYOUT;
    }

    private static final long latitude$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float latitude[3]
     * }
     */
    public static final long latitude$offset() {
        return latitude$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float latitude[3]
     * }
     */
    public static MemorySegment latitude(MemorySegment struct) {
        return struct.asSlice(latitude$OFFSET, latitude$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float latitude[3]
     * }
     */
    public static void latitude(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, latitude$OFFSET, latitude$LAYOUT.byteSize());
    }

    private static long[] latitude$DIMS = { 3 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float latitude[3]
     * }
     */
    public static long[] latitude$dimensions() {
        return latitude$DIMS;
    }
    private static final VarHandle latitude$ELEM_HANDLE = latitude$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float latitude[3]
     * }
     */
    public static float latitude(MemorySegment struct, long index0) {
        return (float)latitude$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float latitude[3]
     * }
     */
    public static void latitude(MemorySegment struct, long index0, float fieldValue) {
        latitude$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout longitude$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("longitude"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float longitude[3]
     * }
     */
    public static final SequenceLayout longitude$layout() {
        return longitude$LAYOUT;
    }

    private static final long longitude$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float longitude[3]
     * }
     */
    public static final long longitude$offset() {
        return longitude$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float longitude[3]
     * }
     */
    public static MemorySegment longitude(MemorySegment struct) {
        return struct.asSlice(longitude$OFFSET, longitude$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float longitude[3]
     * }
     */
    public static void longitude(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, longitude$OFFSET, longitude$LAYOUT.byteSize());
    }

    private static long[] longitude$DIMS = { 3 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float longitude[3]
     * }
     */
    public static long[] longitude$dimensions() {
        return longitude$DIMS;
    }
    private static final VarHandle longitude$ELEM_HANDLE = longitude$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float longitude[3]
     * }
     */
    public static float longitude(MemorySegment struct, long index0) {
        return (float)longitude$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float longitude[3]
     * }
     */
    public static void longitude(MemorySegment struct, long index0, float fieldValue) {
        longitude$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout gpstimestamp$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("gpstimestamp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float gpstimestamp[3]
     * }
     */
    public static final SequenceLayout gpstimestamp$layout() {
        return gpstimestamp$LAYOUT;
    }

    private static final long gpstimestamp$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float gpstimestamp[3]
     * }
     */
    public static final long gpstimestamp$offset() {
        return gpstimestamp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float gpstimestamp[3]
     * }
     */
    public static MemorySegment gpstimestamp(MemorySegment struct) {
        return struct.asSlice(gpstimestamp$OFFSET, gpstimestamp$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float gpstimestamp[3]
     * }
     */
    public static void gpstimestamp(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, gpstimestamp$OFFSET, gpstimestamp$LAYOUT.byteSize());
    }

    private static long[] gpstimestamp$DIMS = { 3 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float gpstimestamp[3]
     * }
     */
    public static long[] gpstimestamp$dimensions() {
        return gpstimestamp$DIMS;
    }
    private static final VarHandle gpstimestamp$ELEM_HANDLE = gpstimestamp$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float gpstimestamp[3]
     * }
     */
    public static float gpstimestamp(MemorySegment struct, long index0) {
        return (float)gpstimestamp$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float gpstimestamp[3]
     * }
     */
    public static void gpstimestamp(MemorySegment struct, long index0, float fieldValue) {
        gpstimestamp$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfFloat altitude$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("altitude"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float altitude
     * }
     */
    public static final OfFloat altitude$layout() {
        return altitude$LAYOUT;
    }

    private static final long altitude$OFFSET = 36;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float altitude
     * }
     */
    public static final long altitude$offset() {
        return altitude$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float altitude
     * }
     */
    public static float altitude(MemorySegment struct) {
        return struct.get(altitude$LAYOUT, altitude$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float altitude
     * }
     */
    public static void altitude(MemorySegment struct, float fieldValue) {
        struct.set(altitude$LAYOUT, altitude$OFFSET, fieldValue);
    }

    private static final OfByte altref$LAYOUT = (OfByte)$LAYOUT.select(groupElement("altref"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char altref
     * }
     */
    public static final OfByte altref$layout() {
        return altref$LAYOUT;
    }

    private static final long altref$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char altref
     * }
     */
    public static final long altref$offset() {
        return altref$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char altref
     * }
     */
    public static byte altref(MemorySegment struct) {
        return struct.get(altref$LAYOUT, altref$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char altref
     * }
     */
    public static void altref(MemorySegment struct, byte fieldValue) {
        struct.set(altref$LAYOUT, altref$OFFSET, fieldValue);
    }

    private static final OfByte latref$LAYOUT = (OfByte)$LAYOUT.select(groupElement("latref"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char latref
     * }
     */
    public static final OfByte latref$layout() {
        return latref$LAYOUT;
    }

    private static final long latref$OFFSET = 41;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char latref
     * }
     */
    public static final long latref$offset() {
        return latref$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char latref
     * }
     */
    public static byte latref(MemorySegment struct) {
        return struct.get(latref$LAYOUT, latref$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char latref
     * }
     */
    public static void latref(MemorySegment struct, byte fieldValue) {
        struct.set(latref$LAYOUT, latref$OFFSET, fieldValue);
    }

    private static final OfByte longref$LAYOUT = (OfByte)$LAYOUT.select(groupElement("longref"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char longref
     * }
     */
    public static final OfByte longref$layout() {
        return longref$LAYOUT;
    }

    private static final long longref$OFFSET = 42;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char longref
     * }
     */
    public static final long longref$offset() {
        return longref$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char longref
     * }
     */
    public static byte longref(MemorySegment struct) {
        return struct.get(longref$LAYOUT, longref$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char longref
     * }
     */
    public static void longref(MemorySegment struct, byte fieldValue) {
        struct.set(longref$LAYOUT, longref$OFFSET, fieldValue);
    }

    private static final OfByte gpsstatus$LAYOUT = (OfByte)$LAYOUT.select(groupElement("gpsstatus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char gpsstatus
     * }
     */
    public static final OfByte gpsstatus$layout() {
        return gpsstatus$LAYOUT;
    }

    private static final long gpsstatus$OFFSET = 43;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char gpsstatus
     * }
     */
    public static final long gpsstatus$offset() {
        return gpsstatus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char gpsstatus
     * }
     */
    public static byte gpsstatus(MemorySegment struct) {
        return struct.get(gpsstatus$LAYOUT, gpsstatus$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char gpsstatus
     * }
     */
    public static void gpsstatus(MemorySegment struct, byte fieldValue) {
        struct.set(gpsstatus$LAYOUT, gpsstatus$OFFSET, fieldValue);
    }

    private static final OfByte gpsparsed$LAYOUT = (OfByte)$LAYOUT.select(groupElement("gpsparsed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char gpsparsed
     * }
     */
    public static final OfByte gpsparsed$layout() {
        return gpsparsed$LAYOUT;
    }

    private static final long gpsparsed$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char gpsparsed
     * }
     */
    public static final long gpsparsed$offset() {
        return gpsparsed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char gpsparsed
     * }
     */
    public static byte gpsparsed(MemorySegment struct) {
        return struct.get(gpsparsed$LAYOUT, gpsparsed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char gpsparsed
     * }
     */
    public static void gpsparsed(MemorySegment struct, byte fieldValue) {
        struct.set(gpsparsed$LAYOUT, gpsparsed$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

