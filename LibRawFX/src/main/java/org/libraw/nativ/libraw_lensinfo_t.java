// Generated by jextract

package org.libraw.nativ;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct {
 *     float MinFocal;
 *     float MaxFocal;
 *     float MaxAp4MinFocal;
 *     float MaxAp4MaxFocal;
 *     float EXIF_MaxAp;
 *     char LensMake[128];
 *     char Lens[128];
 *     char LensSerial[128];
 *     char InternalLensSerial[128];
 *     ushort FocalLengthIn35mmFormat;
 *     libraw_nikonlens_t nikon;
 *     libraw_dnglens_t dng;
 *     libraw_makernotes_lens_t makernotes;
 * }
 * }
 */
public class libraw_lensinfo_t {

    libraw_lensinfo_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        libraw_h.C_FLOAT.withName("MinFocal"),
        libraw_h.C_FLOAT.withName("MaxFocal"),
        libraw_h.C_FLOAT.withName("MaxAp4MinFocal"),
        libraw_h.C_FLOAT.withName("MaxAp4MaxFocal"),
        libraw_h.C_FLOAT.withName("EXIF_MaxAp"),
        MemoryLayout.sequenceLayout(128, libraw_h.C_CHAR).withName("LensMake"),
        MemoryLayout.sequenceLayout(128, libraw_h.C_CHAR).withName("Lens"),
        MemoryLayout.sequenceLayout(128, libraw_h.C_CHAR).withName("LensSerial"),
        MemoryLayout.sequenceLayout(128, libraw_h.C_CHAR).withName("InternalLensSerial"),
        libraw_h.C_SHORT.withName("FocalLengthIn35mmFormat"),
        MemoryLayout.paddingLayout(2),
        libraw_nikonlens_t.layout().withName("nikon"),
        libraw_dnglens_t.layout().withName("dng"),
        libraw_makernotes_lens_t.layout().withName("makernotes")
    ).withName("$anon$1018:11");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfFloat MinFocal$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("MinFocal"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float MinFocal
     * }
     */
    public static final OfFloat MinFocal$layout() {
        return MinFocal$LAYOUT;
    }

    private static final long MinFocal$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float MinFocal
     * }
     */
    public static final long MinFocal$offset() {
        return MinFocal$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float MinFocal
     * }
     */
    public static float MinFocal(MemorySegment struct) {
        return struct.get(MinFocal$LAYOUT, MinFocal$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float MinFocal
     * }
     */
    public static void MinFocal(MemorySegment struct, float fieldValue) {
        struct.set(MinFocal$LAYOUT, MinFocal$OFFSET, fieldValue);
    }

    private static final OfFloat MaxFocal$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("MaxFocal"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float MaxFocal
     * }
     */
    public static final OfFloat MaxFocal$layout() {
        return MaxFocal$LAYOUT;
    }

    private static final long MaxFocal$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float MaxFocal
     * }
     */
    public static final long MaxFocal$offset() {
        return MaxFocal$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float MaxFocal
     * }
     */
    public static float MaxFocal(MemorySegment struct) {
        return struct.get(MaxFocal$LAYOUT, MaxFocal$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float MaxFocal
     * }
     */
    public static void MaxFocal(MemorySegment struct, float fieldValue) {
        struct.set(MaxFocal$LAYOUT, MaxFocal$OFFSET, fieldValue);
    }

    private static final OfFloat MaxAp4MinFocal$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("MaxAp4MinFocal"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float MaxAp4MinFocal
     * }
     */
    public static final OfFloat MaxAp4MinFocal$layout() {
        return MaxAp4MinFocal$LAYOUT;
    }

    private static final long MaxAp4MinFocal$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float MaxAp4MinFocal
     * }
     */
    public static final long MaxAp4MinFocal$offset() {
        return MaxAp4MinFocal$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float MaxAp4MinFocal
     * }
     */
    public static float MaxAp4MinFocal(MemorySegment struct) {
        return struct.get(MaxAp4MinFocal$LAYOUT, MaxAp4MinFocal$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float MaxAp4MinFocal
     * }
     */
    public static void MaxAp4MinFocal(MemorySegment struct, float fieldValue) {
        struct.set(MaxAp4MinFocal$LAYOUT, MaxAp4MinFocal$OFFSET, fieldValue);
    }

    private static final OfFloat MaxAp4MaxFocal$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("MaxAp4MaxFocal"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float MaxAp4MaxFocal
     * }
     */
    public static final OfFloat MaxAp4MaxFocal$layout() {
        return MaxAp4MaxFocal$LAYOUT;
    }

    private static final long MaxAp4MaxFocal$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float MaxAp4MaxFocal
     * }
     */
    public static final long MaxAp4MaxFocal$offset() {
        return MaxAp4MaxFocal$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float MaxAp4MaxFocal
     * }
     */
    public static float MaxAp4MaxFocal(MemorySegment struct) {
        return struct.get(MaxAp4MaxFocal$LAYOUT, MaxAp4MaxFocal$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float MaxAp4MaxFocal
     * }
     */
    public static void MaxAp4MaxFocal(MemorySegment struct, float fieldValue) {
        struct.set(MaxAp4MaxFocal$LAYOUT, MaxAp4MaxFocal$OFFSET, fieldValue);
    }

    private static final OfFloat EXIF_MaxAp$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("EXIF_MaxAp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float EXIF_MaxAp
     * }
     */
    public static final OfFloat EXIF_MaxAp$layout() {
        return EXIF_MaxAp$LAYOUT;
    }

    private static final long EXIF_MaxAp$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float EXIF_MaxAp
     * }
     */
    public static final long EXIF_MaxAp$offset() {
        return EXIF_MaxAp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float EXIF_MaxAp
     * }
     */
    public static float EXIF_MaxAp(MemorySegment struct) {
        return struct.get(EXIF_MaxAp$LAYOUT, EXIF_MaxAp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float EXIF_MaxAp
     * }
     */
    public static void EXIF_MaxAp(MemorySegment struct, float fieldValue) {
        struct.set(EXIF_MaxAp$LAYOUT, EXIF_MaxAp$OFFSET, fieldValue);
    }

    private static final SequenceLayout LensMake$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("LensMake"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char LensMake[128]
     * }
     */
    public static final SequenceLayout LensMake$layout() {
        return LensMake$LAYOUT;
    }

    private static final long LensMake$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char LensMake[128]
     * }
     */
    public static final long LensMake$offset() {
        return LensMake$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char LensMake[128]
     * }
     */
    public static MemorySegment LensMake(MemorySegment struct) {
        return struct.asSlice(LensMake$OFFSET, LensMake$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char LensMake[128]
     * }
     */
    public static void LensMake(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, LensMake$OFFSET, LensMake$LAYOUT.byteSize());
    }

    private static long[] LensMake$DIMS = { 128 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char LensMake[128]
     * }
     */
    public static long[] LensMake$dimensions() {
        return LensMake$DIMS;
    }
    private static final VarHandle LensMake$ELEM_HANDLE = LensMake$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char LensMake[128]
     * }
     */
    public static byte LensMake(MemorySegment struct, long index0) {
        return (byte)LensMake$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char LensMake[128]
     * }
     */
    public static void LensMake(MemorySegment struct, long index0, byte fieldValue) {
        LensMake$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout Lens$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("Lens"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char Lens[128]
     * }
     */
    public static final SequenceLayout Lens$layout() {
        return Lens$LAYOUT;
    }

    private static final long Lens$OFFSET = 148;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char Lens[128]
     * }
     */
    public static final long Lens$offset() {
        return Lens$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char Lens[128]
     * }
     */
    public static MemorySegment Lens(MemorySegment struct) {
        return struct.asSlice(Lens$OFFSET, Lens$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char Lens[128]
     * }
     */
    public static void Lens(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, Lens$OFFSET, Lens$LAYOUT.byteSize());
    }

    private static long[] Lens$DIMS = { 128 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char Lens[128]
     * }
     */
    public static long[] Lens$dimensions() {
        return Lens$DIMS;
    }
    private static final VarHandle Lens$ELEM_HANDLE = Lens$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char Lens[128]
     * }
     */
    public static byte Lens(MemorySegment struct, long index0) {
        return (byte)Lens$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char Lens[128]
     * }
     */
    public static void Lens(MemorySegment struct, long index0, byte fieldValue) {
        Lens$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout LensSerial$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("LensSerial"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char LensSerial[128]
     * }
     */
    public static final SequenceLayout LensSerial$layout() {
        return LensSerial$LAYOUT;
    }

    private static final long LensSerial$OFFSET = 276;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char LensSerial[128]
     * }
     */
    public static final long LensSerial$offset() {
        return LensSerial$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char LensSerial[128]
     * }
     */
    public static MemorySegment LensSerial(MemorySegment struct) {
        return struct.asSlice(LensSerial$OFFSET, LensSerial$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char LensSerial[128]
     * }
     */
    public static void LensSerial(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, LensSerial$OFFSET, LensSerial$LAYOUT.byteSize());
    }

    private static long[] LensSerial$DIMS = { 128 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char LensSerial[128]
     * }
     */
    public static long[] LensSerial$dimensions() {
        return LensSerial$DIMS;
    }
    private static final VarHandle LensSerial$ELEM_HANDLE = LensSerial$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char LensSerial[128]
     * }
     */
    public static byte LensSerial(MemorySegment struct, long index0) {
        return (byte)LensSerial$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char LensSerial[128]
     * }
     */
    public static void LensSerial(MemorySegment struct, long index0, byte fieldValue) {
        LensSerial$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout InternalLensSerial$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("InternalLensSerial"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char InternalLensSerial[128]
     * }
     */
    public static final SequenceLayout InternalLensSerial$layout() {
        return InternalLensSerial$LAYOUT;
    }

    private static final long InternalLensSerial$OFFSET = 404;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char InternalLensSerial[128]
     * }
     */
    public static final long InternalLensSerial$offset() {
        return InternalLensSerial$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char InternalLensSerial[128]
     * }
     */
    public static MemorySegment InternalLensSerial(MemorySegment struct) {
        return struct.asSlice(InternalLensSerial$OFFSET, InternalLensSerial$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char InternalLensSerial[128]
     * }
     */
    public static void InternalLensSerial(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, InternalLensSerial$OFFSET, InternalLensSerial$LAYOUT.byteSize());
    }

    private static long[] InternalLensSerial$DIMS = { 128 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char InternalLensSerial[128]
     * }
     */
    public static long[] InternalLensSerial$dimensions() {
        return InternalLensSerial$DIMS;
    }
    private static final VarHandle InternalLensSerial$ELEM_HANDLE = InternalLensSerial$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char InternalLensSerial[128]
     * }
     */
    public static byte InternalLensSerial(MemorySegment struct, long index0) {
        return (byte)InternalLensSerial$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char InternalLensSerial[128]
     * }
     */
    public static void InternalLensSerial(MemorySegment struct, long index0, byte fieldValue) {
        InternalLensSerial$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfShort FocalLengthIn35mmFormat$LAYOUT = (OfShort)$LAYOUT.select(groupElement("FocalLengthIn35mmFormat"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ushort FocalLengthIn35mmFormat
     * }
     */
    public static final OfShort FocalLengthIn35mmFormat$layout() {
        return FocalLengthIn35mmFormat$LAYOUT;
    }

    private static final long FocalLengthIn35mmFormat$OFFSET = 532;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ushort FocalLengthIn35mmFormat
     * }
     */
    public static final long FocalLengthIn35mmFormat$offset() {
        return FocalLengthIn35mmFormat$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ushort FocalLengthIn35mmFormat
     * }
     */
    public static short FocalLengthIn35mmFormat(MemorySegment struct) {
        return struct.get(FocalLengthIn35mmFormat$LAYOUT, FocalLengthIn35mmFormat$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ushort FocalLengthIn35mmFormat
     * }
     */
    public static void FocalLengthIn35mmFormat(MemorySegment struct, short fieldValue) {
        struct.set(FocalLengthIn35mmFormat$LAYOUT, FocalLengthIn35mmFormat$OFFSET, fieldValue);
    }

    private static final GroupLayout nikon$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("nikon"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * libraw_nikonlens_t nikon
     * }
     */
    public static final GroupLayout nikon$layout() {
        return nikon$LAYOUT;
    }

    private static final long nikon$OFFSET = 536;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * libraw_nikonlens_t nikon
     * }
     */
    public static final long nikon$offset() {
        return nikon$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * libraw_nikonlens_t nikon
     * }
     */
    public static MemorySegment nikon(MemorySegment struct) {
        return struct.asSlice(nikon$OFFSET, nikon$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * libraw_nikonlens_t nikon
     * }
     */
    public static void nikon(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, nikon$OFFSET, nikon$LAYOUT.byteSize());
    }

    private static final GroupLayout dng$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("dng"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * libraw_dnglens_t dng
     * }
     */
    public static final GroupLayout dng$layout() {
        return dng$LAYOUT;
    }

    private static final long dng$OFFSET = 544;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * libraw_dnglens_t dng
     * }
     */
    public static final long dng$offset() {
        return dng$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * libraw_dnglens_t dng
     * }
     */
    public static MemorySegment dng(MemorySegment struct) {
        return struct.asSlice(dng$OFFSET, dng$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * libraw_dnglens_t dng
     * }
     */
    public static void dng(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, dng$OFFSET, dng$LAYOUT.byteSize());
    }

    private static final GroupLayout makernotes$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("makernotes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * libraw_makernotes_lens_t makernotes
     * }
     */
    public static final GroupLayout makernotes$layout() {
        return makernotes$LAYOUT;
    }

    private static final long makernotes$OFFSET = 560;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * libraw_makernotes_lens_t makernotes
     * }
     */
    public static final long makernotes$offset() {
        return makernotes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * libraw_makernotes_lens_t makernotes
     * }
     */
    public static MemorySegment makernotes(MemorySegment struct) {
        return struct.asSlice(makernotes$OFFSET, makernotes$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * libraw_makernotes_lens_t makernotes
     * }
     */
    public static void makernotes(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, makernotes$OFFSET, makernotes$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

