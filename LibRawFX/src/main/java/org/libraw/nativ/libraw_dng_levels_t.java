// Generated by jextract

package org.libraw.nativ;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct {
 *     unsigned int parsedfields;
 *     unsigned int dng_cblack[4104];
 *     unsigned int dng_black;
 *     float dng_fcblack[4104];
 *     float dng_fblack;
 *     unsigned int dng_whitelevel[4];
 *     ushort default_crop[4];
 *     float user_crop[4];
 *     unsigned int preview_colorspace;
 *     float analogbalance[4];
 *     float asshotneutral[4];
 *     float baseline_exposure;
 *     float LinearResponseLimit;
 * }
 * }
 */
public class libraw_dng_levels_t {

    libraw_dng_levels_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        libraw_h.C_INT.withName("parsedfields"),
        MemoryLayout.sequenceLayout(4104, libraw_h.C_INT).withName("dng_cblack"),
        libraw_h.C_INT.withName("dng_black"),
        MemoryLayout.sequenceLayout(4104, libraw_h.C_FLOAT).withName("dng_fcblack"),
        libraw_h.C_FLOAT.withName("dng_fblack"),
        MemoryLayout.sequenceLayout(4, libraw_h.C_INT).withName("dng_whitelevel"),
        MemoryLayout.sequenceLayout(4, libraw_h.C_SHORT).withName("default_crop"),
        MemoryLayout.sequenceLayout(4, libraw_h.C_FLOAT).withName("user_crop"),
        libraw_h.C_INT.withName("preview_colorspace"),
        MemoryLayout.sequenceLayout(4, libraw_h.C_FLOAT).withName("analogbalance"),
        MemoryLayout.sequenceLayout(4, libraw_h.C_FLOAT).withName("asshotneutral"),
        libraw_h.C_FLOAT.withName("baseline_exposure"),
        libraw_h.C_FLOAT.withName("LinearResponseLimit")
    ).withName("$anon$238:11");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt parsedfields$LAYOUT = (OfInt)$LAYOUT.select(groupElement("parsedfields"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int parsedfields
     * }
     */
    public static final OfInt parsedfields$layout() {
        return parsedfields$LAYOUT;
    }

    private static final long parsedfields$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int parsedfields
     * }
     */
    public static final long parsedfields$offset() {
        return parsedfields$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int parsedfields
     * }
     */
    public static int parsedfields(MemorySegment struct) {
        return struct.get(parsedfields$LAYOUT, parsedfields$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int parsedfields
     * }
     */
    public static void parsedfields(MemorySegment struct, int fieldValue) {
        struct.set(parsedfields$LAYOUT, parsedfields$OFFSET, fieldValue);
    }

    private static final SequenceLayout dng_cblack$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("dng_cblack"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int dng_cblack[4104]
     * }
     */
    public static final SequenceLayout dng_cblack$layout() {
        return dng_cblack$LAYOUT;
    }

    private static final long dng_cblack$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int dng_cblack[4104]
     * }
     */
    public static final long dng_cblack$offset() {
        return dng_cblack$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int dng_cblack[4104]
     * }
     */
    public static MemorySegment dng_cblack(MemorySegment struct) {
        return struct.asSlice(dng_cblack$OFFSET, dng_cblack$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int dng_cblack[4104]
     * }
     */
    public static void dng_cblack(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, dng_cblack$OFFSET, dng_cblack$LAYOUT.byteSize());
    }

    private static long[] dng_cblack$DIMS = { 4104 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * unsigned int dng_cblack[4104]
     * }
     */
    public static long[] dng_cblack$dimensions() {
        return dng_cblack$DIMS;
    }
    private static final VarHandle dng_cblack$ELEM_HANDLE = dng_cblack$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * unsigned int dng_cblack[4104]
     * }
     */
    public static int dng_cblack(MemorySegment struct, long index0) {
        return (int)dng_cblack$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * unsigned int dng_cblack[4104]
     * }
     */
    public static void dng_cblack(MemorySegment struct, long index0, int fieldValue) {
        dng_cblack$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfInt dng_black$LAYOUT = (OfInt)$LAYOUT.select(groupElement("dng_black"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int dng_black
     * }
     */
    public static final OfInt dng_black$layout() {
        return dng_black$LAYOUT;
    }

    private static final long dng_black$OFFSET = 16420;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int dng_black
     * }
     */
    public static final long dng_black$offset() {
        return dng_black$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int dng_black
     * }
     */
    public static int dng_black(MemorySegment struct) {
        return struct.get(dng_black$LAYOUT, dng_black$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int dng_black
     * }
     */
    public static void dng_black(MemorySegment struct, int fieldValue) {
        struct.set(dng_black$LAYOUT, dng_black$OFFSET, fieldValue);
    }

    private static final SequenceLayout dng_fcblack$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("dng_fcblack"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float dng_fcblack[4104]
     * }
     */
    public static final SequenceLayout dng_fcblack$layout() {
        return dng_fcblack$LAYOUT;
    }

    private static final long dng_fcblack$OFFSET = 16424;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float dng_fcblack[4104]
     * }
     */
    public static final long dng_fcblack$offset() {
        return dng_fcblack$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float dng_fcblack[4104]
     * }
     */
    public static MemorySegment dng_fcblack(MemorySegment struct) {
        return struct.asSlice(dng_fcblack$OFFSET, dng_fcblack$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float dng_fcblack[4104]
     * }
     */
    public static void dng_fcblack(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, dng_fcblack$OFFSET, dng_fcblack$LAYOUT.byteSize());
    }

    private static long[] dng_fcblack$DIMS = { 4104 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float dng_fcblack[4104]
     * }
     */
    public static long[] dng_fcblack$dimensions() {
        return dng_fcblack$DIMS;
    }
    private static final VarHandle dng_fcblack$ELEM_HANDLE = dng_fcblack$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float dng_fcblack[4104]
     * }
     */
    public static float dng_fcblack(MemorySegment struct, long index0) {
        return (float)dng_fcblack$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float dng_fcblack[4104]
     * }
     */
    public static void dng_fcblack(MemorySegment struct, long index0, float fieldValue) {
        dng_fcblack$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfFloat dng_fblack$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("dng_fblack"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float dng_fblack
     * }
     */
    public static final OfFloat dng_fblack$layout() {
        return dng_fblack$LAYOUT;
    }

    private static final long dng_fblack$OFFSET = 32840;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float dng_fblack
     * }
     */
    public static final long dng_fblack$offset() {
        return dng_fblack$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float dng_fblack
     * }
     */
    public static float dng_fblack(MemorySegment struct) {
        return struct.get(dng_fblack$LAYOUT, dng_fblack$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float dng_fblack
     * }
     */
    public static void dng_fblack(MemorySegment struct, float fieldValue) {
        struct.set(dng_fblack$LAYOUT, dng_fblack$OFFSET, fieldValue);
    }

    private static final SequenceLayout dng_whitelevel$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("dng_whitelevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int dng_whitelevel[4]
     * }
     */
    public static final SequenceLayout dng_whitelevel$layout() {
        return dng_whitelevel$LAYOUT;
    }

    private static final long dng_whitelevel$OFFSET = 32844;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int dng_whitelevel[4]
     * }
     */
    public static final long dng_whitelevel$offset() {
        return dng_whitelevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int dng_whitelevel[4]
     * }
     */
    public static MemorySegment dng_whitelevel(MemorySegment struct) {
        return struct.asSlice(dng_whitelevel$OFFSET, dng_whitelevel$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int dng_whitelevel[4]
     * }
     */
    public static void dng_whitelevel(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, dng_whitelevel$OFFSET, dng_whitelevel$LAYOUT.byteSize());
    }

    private static long[] dng_whitelevel$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * unsigned int dng_whitelevel[4]
     * }
     */
    public static long[] dng_whitelevel$dimensions() {
        return dng_whitelevel$DIMS;
    }
    private static final VarHandle dng_whitelevel$ELEM_HANDLE = dng_whitelevel$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * unsigned int dng_whitelevel[4]
     * }
     */
    public static int dng_whitelevel(MemorySegment struct, long index0) {
        return (int)dng_whitelevel$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * unsigned int dng_whitelevel[4]
     * }
     */
    public static void dng_whitelevel(MemorySegment struct, long index0, int fieldValue) {
        dng_whitelevel$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout default_crop$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("default_crop"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ushort default_crop[4]
     * }
     */
    public static final SequenceLayout default_crop$layout() {
        return default_crop$LAYOUT;
    }

    private static final long default_crop$OFFSET = 32860;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ushort default_crop[4]
     * }
     */
    public static final long default_crop$offset() {
        return default_crop$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ushort default_crop[4]
     * }
     */
    public static MemorySegment default_crop(MemorySegment struct) {
        return struct.asSlice(default_crop$OFFSET, default_crop$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ushort default_crop[4]
     * }
     */
    public static void default_crop(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, default_crop$OFFSET, default_crop$LAYOUT.byteSize());
    }

    private static long[] default_crop$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * ushort default_crop[4]
     * }
     */
    public static long[] default_crop$dimensions() {
        return default_crop$DIMS;
    }
    private static final VarHandle default_crop$ELEM_HANDLE = default_crop$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * ushort default_crop[4]
     * }
     */
    public static short default_crop(MemorySegment struct, long index0) {
        return (short)default_crop$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * ushort default_crop[4]
     * }
     */
    public static void default_crop(MemorySegment struct, long index0, short fieldValue) {
        default_crop$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout user_crop$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("user_crop"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float user_crop[4]
     * }
     */
    public static final SequenceLayout user_crop$layout() {
        return user_crop$LAYOUT;
    }

    private static final long user_crop$OFFSET = 32868;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float user_crop[4]
     * }
     */
    public static final long user_crop$offset() {
        return user_crop$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float user_crop[4]
     * }
     */
    public static MemorySegment user_crop(MemorySegment struct) {
        return struct.asSlice(user_crop$OFFSET, user_crop$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float user_crop[4]
     * }
     */
    public static void user_crop(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, user_crop$OFFSET, user_crop$LAYOUT.byteSize());
    }

    private static long[] user_crop$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float user_crop[4]
     * }
     */
    public static long[] user_crop$dimensions() {
        return user_crop$DIMS;
    }
    private static final VarHandle user_crop$ELEM_HANDLE = user_crop$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float user_crop[4]
     * }
     */
    public static float user_crop(MemorySegment struct, long index0) {
        return (float)user_crop$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float user_crop[4]
     * }
     */
    public static void user_crop(MemorySegment struct, long index0, float fieldValue) {
        user_crop$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfInt preview_colorspace$LAYOUT = (OfInt)$LAYOUT.select(groupElement("preview_colorspace"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int preview_colorspace
     * }
     */
    public static final OfInt preview_colorspace$layout() {
        return preview_colorspace$LAYOUT;
    }

    private static final long preview_colorspace$OFFSET = 32884;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int preview_colorspace
     * }
     */
    public static final long preview_colorspace$offset() {
        return preview_colorspace$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int preview_colorspace
     * }
     */
    public static int preview_colorspace(MemorySegment struct) {
        return struct.get(preview_colorspace$LAYOUT, preview_colorspace$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int preview_colorspace
     * }
     */
    public static void preview_colorspace(MemorySegment struct, int fieldValue) {
        struct.set(preview_colorspace$LAYOUT, preview_colorspace$OFFSET, fieldValue);
    }

    private static final SequenceLayout analogbalance$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("analogbalance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static final SequenceLayout analogbalance$layout() {
        return analogbalance$LAYOUT;
    }

    private static final long analogbalance$OFFSET = 32888;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static final long analogbalance$offset() {
        return analogbalance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static MemorySegment analogbalance(MemorySegment struct) {
        return struct.asSlice(analogbalance$OFFSET, analogbalance$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static void analogbalance(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, analogbalance$OFFSET, analogbalance$LAYOUT.byteSize());
    }

    private static long[] analogbalance$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static long[] analogbalance$dimensions() {
        return analogbalance$DIMS;
    }
    private static final VarHandle analogbalance$ELEM_HANDLE = analogbalance$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static float analogbalance(MemorySegment struct, long index0) {
        return (float)analogbalance$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float analogbalance[4]
     * }
     */
    public static void analogbalance(MemorySegment struct, long index0, float fieldValue) {
        analogbalance$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout asshotneutral$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("asshotneutral"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float asshotneutral[4]
     * }
     */
    public static final SequenceLayout asshotneutral$layout() {
        return asshotneutral$LAYOUT;
    }

    private static final long asshotneutral$OFFSET = 32904;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float asshotneutral[4]
     * }
     */
    public static final long asshotneutral$offset() {
        return asshotneutral$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float asshotneutral[4]
     * }
     */
    public static MemorySegment asshotneutral(MemorySegment struct) {
        return struct.asSlice(asshotneutral$OFFSET, asshotneutral$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float asshotneutral[4]
     * }
     */
    public static void asshotneutral(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, asshotneutral$OFFSET, asshotneutral$LAYOUT.byteSize());
    }

    private static long[] asshotneutral$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float asshotneutral[4]
     * }
     */
    public static long[] asshotneutral$dimensions() {
        return asshotneutral$DIMS;
    }
    private static final VarHandle asshotneutral$ELEM_HANDLE = asshotneutral$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float asshotneutral[4]
     * }
     */
    public static float asshotneutral(MemorySegment struct, long index0) {
        return (float)asshotneutral$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float asshotneutral[4]
     * }
     */
    public static void asshotneutral(MemorySegment struct, long index0, float fieldValue) {
        asshotneutral$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfFloat baseline_exposure$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("baseline_exposure"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float baseline_exposure
     * }
     */
    public static final OfFloat baseline_exposure$layout() {
        return baseline_exposure$LAYOUT;
    }

    private static final long baseline_exposure$OFFSET = 32920;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float baseline_exposure
     * }
     */
    public static final long baseline_exposure$offset() {
        return baseline_exposure$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float baseline_exposure
     * }
     */
    public static float baseline_exposure(MemorySegment struct) {
        return struct.get(baseline_exposure$LAYOUT, baseline_exposure$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float baseline_exposure
     * }
     */
    public static void baseline_exposure(MemorySegment struct, float fieldValue) {
        struct.set(baseline_exposure$LAYOUT, baseline_exposure$OFFSET, fieldValue);
    }

    private static final OfFloat LinearResponseLimit$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("LinearResponseLimit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float LinearResponseLimit
     * }
     */
    public static final OfFloat LinearResponseLimit$layout() {
        return LinearResponseLimit$LAYOUT;
    }

    private static final long LinearResponseLimit$OFFSET = 32924;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float LinearResponseLimit
     * }
     */
    public static final long LinearResponseLimit$offset() {
        return LinearResponseLimit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float LinearResponseLimit
     * }
     */
    public static float LinearResponseLimit(MemorySegment struct) {
        return struct.get(LinearResponseLimit$LAYOUT, LinearResponseLimit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float LinearResponseLimit
     * }
     */
    public static void LinearResponseLimit(MemorySegment struct, float fieldValue) {
        struct.set(LinearResponseLimit$LAYOUT, LinearResponseLimit$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size @code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size @code elementCount} using {@code allocator}.
     * The returned segment has size @code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size @code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size @code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

